import json
import sys
import unittest, time

from pjscan.cache.thread_pool import *
from pjscan.analysis_framework import *
from Vulnerability_detect.template import *
from Vulnerability_detect.result_record import *
from pjscan.graph_traversal import *
from pjscan.graph_traversal import GlobalPDGForwardTraversal
from ForwardTask import *

class ForwardTraversal(GlobalPDGForwardTraversal):
    def __init__(self, *args, **kwargs):

        super(ForwardTraversal, self).__init__(*args, **kwargs)

        self.cache_graph = self.analysis_framework.cache
        self.thread_pool = PrefetchPool.from_analyzer(self.analysis_framework,thread_count=6)
        self.origin, self.origin_id = self.find_origin()
        self.terminal, self.terminal_id, self.terminal_node = self.find_terminal()
        self.sanitizer = self.find_sanitizer()
        self.get_call_return = lambda x: self.cache_graph.customize_storage['call_return'].get(x, None)
        self.set_call_return = lambda k, v: self.cache_graph.customize_storage['call_return'].__setitem__(k, v)
        self.node_without_cache_hit = []
    def find_origin(self):
        origin_node = []
        for node_id in CVE_2014_6316_SOURCE:
            origin_node.extend(
                    self.analysis_framework.basic_step.match(**{NODE_INDEX: node_id, }).all())


        print(f"the number of origin is:" + str(len(origin_node)))
        return origin_node,[i[NODE_INDEX] for i in origin_node]

    def find_sanitizer(self):
        return [lambda x,**kwargs:False]
        target_nodes = []
        for sanitizer_function in TEST_SANITIZER:
            target_nodes.extend(
                    self.analysis_framework.neo4j_graph.nodes.match(**{NODE_CODE: sanitizer_function, }).all())
        result_node = []
        for target_node in target_nodes:
            node = self.analysis_framework.ast_step.get_root_node(target_node)
            if node is not None:
                result_node.append(node)
        sanitizer_nodes_id = []
        for sanitizer_node in result_node:
            sanitizer_nodes_id.append(sanitizer_node[NODE_INDEX])
        return [lambda x, **kwargs: x[NODE_INDEX] in sanitizer_nodes_id]

    def find_terminal(self):

        terminal_node = []

        for node_id in CVE_2014_6316_SINK:
            terminal_node.extend(self.analysis_framework.neo4j_graph.nodes.match(
                    **{NODE_INDEX: node_id}).all())

        terminal_node_id = [i[NODE_INDEX] for i in terminal_node]
        print(f"the number of origin is:" + str(len(terminal_node)))
        return [lambda x: x[NODE_INDEX] in terminal_node_id], terminal_node_id, terminal_node

    def traversal(self, node, *args, **kwargs):
        if node[NODE_FUNCID] not in self.func_depth:
            self.func_depth[node[NODE_FUNCID]] = 0
        if self.func_depth[node[NODE_FUNCID]] >= self.max_func_depth:
            return []
        result = []

        use_node = self.analysis_framework.pdg_step.find_use_nodes(node)
        result.extend(use_node)
        if node['taint_var'] != '':
            if self.cache_graph.customize_storage['call_decl'].get(node[NODE_INDEX], None) != None and \
                    self.cache_graph.customize_storage['call_decl'][node[NODE_INDEX]].get(
                        node[NODE_INDEX]['taint_var'], None) != None:
                result.extend(self.cache_graph.customize_storage['call_decl'][node[NODE_INDEX]].get(
                        node[NODE_INDEX]['taint_var'], None))
            else:
                if node[NODE_TYPE] not in [TYPE_CALL, TYPE_METHOD_CALL, TYPE_STATIC_CALL, TYPE_NEW]:
                    call_nodes = self.analysis_framework.filter_ast_child_nodes(
                        node,
                        node_type_filter=[TYPE_CALL, TYPE_METHOD_CALL, TYPE_STATIC_CALL, TYPE_NEW]
                    )
                else:
                    call_nodes = [node]
                for call_node in call_nodes:
                    arg_list = self.get_all_arg_var(call_node)
                    for key in arg_list.keys():
                        if key == f"${node['taint_var']}":
                            result_node = self.match_CG_dataflow(call_node, arg_list[key])
                            result.extend(result_node)

        for node in result:
            self.thread_pool.put_task(PDGUseTask(cache_graph=self.cache_graph,node=node))
            self.thread_pool.put_task(CallDeclTask(cache_graph=self.cache_graph, node=node))
        return result
